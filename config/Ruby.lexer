
import jfun.parsec.*;
import jfun.parsec.tokens.*;
import jfun.parsec.pattern.*;



class RubySyntax
    {
    public lexer

    RubySyntax()
        {
        setup()

        myRuleStack << _s( "UNRECOGNIZED", Scanners.anyChar() )

        Parser[] parsers = new Parser[ myRuleStack.size() ]
        for( idx in 0..parsers.length - 1 )
            {
            parsers[ idx ] = myRuleStack[ idx ]
            }

        def l_all = Parsers.alt( parsers )
        def s_whitespace = Scanners.isWhitespaces().many()
        lexer = Lexers.lexeme( s_whitespace, l_all )
        }

    def setup()
        {
        def s_block_open = Scanners.isPattern( Patterns.regex( /(?m:^=begin)/ ), "BLOCK_OPEN" )
        def s_block_close = Scanners.isPattern( Patterns.regex( /(?m:^=end$)/ ), "BLOCK_CLOSE" )
        def s_block_commented = Scanners.anyChar()

        scanner "DOC_COMMENT",	        Scanners.isBlockComment( s_block_open, s_block_close, s_block_commented )

        regex "LINE_COMMENT",           /(?m:#.*$)/
        regex "SPECIAL_QUOTED_STRING",  /%[qQ]\{(?:(?:\\\})|(?:[^\}]))*\}/
        regex "SPECIAL_QUOTED_STRING",  /%[qQ]\[(?:(?:\\\])|(?:[^\]]))*\]/
        regex "SPECIAL_QUOTED_STRING",  /%[qQ]\((?:(?:\\\))|(?:[^\)]))*\)/
        regex "SPECIAL_QUOTED_STRING",  /%[qQ](.).*\1/
        regex "SINGLE_QUOTED_STRING",   /\'(?:[^\'\n\r]|\\')*\'/
        regex "DOUBLE_QUOTED_STRING",   /\"(?:[^\"\n\r]|\\")*\"/

	    regex "KEYWORD",                /\b(?:alias|and|BEGIN|begin|break|case|class|def|defined|do|else|elsif|END|end|ensure|false|for|if|in|module|next|nil|not|or|redo|rescue|retry|return|self|super|then|true|undef|unless|until|when|while|yield)\b/

        regex "CONSTANT",               /\b[A-Z][A-Z_]*\b/
        regex "CLASS_NAME",             /\b[A-Z]*(?:(?:[A-Z][a-z_]+)|[A-Z])+\b/
        regex "INSTANCE_VARIABLE",      /@[a-z_]+\b/
        regex "CLASS_VARIABLE",         /@@[a-z_]+\b/
        regex "SYMBOL",                 /\:\w+\b/
        regex "IDENTIFIER",             /\b[a-z]\w*\b/
        regex "NUMBER",                 /\b(?:0x[0-9A-Fa-f]+)|(?:[0-9]+(?:\.[0-9]+)?)\b/
        }

    def regex( aTokenID, aRegex )
        {
        myRuleStack << _r( aTokenID, aRegex )
        }

    def scanner( aTokenID, aScanner )
        {
        myRuleStack << _s( aTokenID, aScanner )
        }

    def _r( aTokenID, aRegex )
        {
        return _p( aTokenID, Patterns.regex( aRegex ) );
        }

    def _p( aTokenID, aPattern )
        {
        return _s( aTokenID, Scanners.isPattern( aPattern, aTokenID ) );
        }

    def _s( aTokenID, aScanner )
        {
        return Lexers.lexer( aScanner, Tokenizers.forTypedToken( aTokenID ) );
        }

    def myRuleStack = []
    }



return new RubySyntax().lexer
